{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

program stub;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.SysUtils,
  Winapi.Windows,
  uExceptions in '..\..\..\Shared\Delphi\uExceptions.pas',
  uPayload in '..\..\..\Shared\Delphi\uPayload.pas',
  uSharedFunctions in '..\..\..\Shared\Delphi\uSharedFunctions.pas';

{ _.ReadMalwareConfig
  Read Malware Config from target file (usually current) }
procedure ReadMalwareConfig(const AFileName : String; var AConfig : TMalwareConfig); overload;
var hFile      : THandle;
    ABytesRead : DWORD;
begin
  ZeroMemory(@AConfig, SizeOf(TMalwareConfig));
  ///

  WriteLn(Format('Open target file [%s]...', [AFileName]));

  { Get an handle to file with correct permissions }
  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew?WT_mc_id=SEC-MVP-5005282
  hFile := CreateFileW(
    PWideChar(AFileName),
    GENERIC_READ,
    FILE_SHARE_READ,
    nil,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    0
  );
  if hFile = INVALID_HANDLE_VALUE then
    raise EWindowsException.Create('CreateFileW');

  WriteLn(Format('File handle: [%x], move cursor to EOF...', [hFile]));

  { Place file cursor at the end of the file minus the size of malware config structure }
  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer?WT_mc_id=SEC-MVP-5005282
  if SetFilePointer(hFile, -SizeOf(TMalwareConfig), nil, FILE_END) = $FFFFFFFF {INVALID_SET_FILE_POINTER} then
    raise EWindowsException.Create('SetFilePointer');

  { Read EOF (Overlay) Data }
  WriteLn('Read EOF Data...');

  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile?WT_mc_id=SEC-MVP-5005282
  if not ReadFile(hFile, AConfig, SizeOf(TMalwareConfig), ABytesRead, nil) then
    raise EWindowsException.Create('ReadFile');
end;

(* Entry Point*)

var AConfig   : TMalwareConfig;
begin
  try
    WriteLn('Read EOF From File...');

    ReadMalwareConfig(GetModuleName(0), AConfig);

    DumpMalwareConfig(AConfig);

    ///
    WriteLn('Press return key to exit.');
    ReadLn;
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
