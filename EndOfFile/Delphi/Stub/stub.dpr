{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

program stub;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.SysUtils,
  Winapi.Windows,
  uExceptions in '..\Shared\uExceptions.pas',
  uPayload in '..\Shared\uPayload.pas';


(* Local Functions (Helpers) *)

{ _.BufferToHexView }
function BufferToHexView(const pBuffer : PVOID; const ABufferSize : UInt64) : String; overload;
var ARow           : array of byte;
    ABytesRead     : UInt64;
    x              : Byte;
    AStringBuilder : TStringBuilder;
    AHexBuilder    : TStringBuilder;
    AAsciiBuilder  : TStringBuilder;

    function PrintChar(const AChar : Byte) : Char;
    begin
      if AChar in [32..126] then
        result := Chr(AChar)
      else
        result := '.';
    end;

const SPACE = #32;

begin
  result := '';
  ///

  AStringBuilder := TStringBuilder.Create();
  AHexBuilder := TStringBuilder.Create(48);
  AAsciiBuilder := TStringBuilder.Create(16);
  try
    ABytesRead := 0;

    SetLength(ARow, 16);
    repeat
      if ABufferSize - ABytesRead < 16 then
        SetLength(ARow, ABufferSize - ABytesRead);
      ///

      CopyMemory(PByte(ARow), Pointer(NativeUInt(pBuffer) + ABytesRead), Length(ARow));

      AHexBuilder.Clear();
      AAsciiBuilder.Clear();

      for x := 0 to Length(ARow) -1 do begin
        AHexBuilder.Append(SPACE + IntToHex(ARow[x]));
        AAsciiBuilder.Append(PrintChar(ARow[x]));
      end;

      AStringBuilder.AppendLine(
        Format('%p:%p %-48s %s', [
          Pointer(NativeUInt(pBuffer) + ABytesRead),
          Pointer(ABytesRead),
          AHexBuilder.ToString(),
          AAsciiBuilder.ToString()
        ])
      );

      ///
      Inc(ABytesRead, Length(ARow));
    until ABytesRead = ABufferSize;

    ///
    result := AStringBuilder.ToString();
  finally
    if Assigned(AStringBuilder) then
      FreeAndNil(AStringBuilder);

    if Assigned(AHexBuilder) then
      FreeAndNil(AHexBuilder);

    if Assigned(AAsciiBuilder) then
      FreeAndNil(AAsciiBuilder);
  end;
end;

{ _.ReadMalwareConfig
  Read Malware Config from target file (usually current) }
procedure ReadMalwareConfig(const AFileName : String; var AConfig : TMalwareConfig); overload;
var hFile      : THandle;
    ABytesRead : DWORD;
begin
  ZeroMemory(@AConfig, SizeOf(TMalwareConfig));
  ///

  WriteLn(Format('Open target file [%s]...', [AFileName]));

  { Get an handle to file with correct permissions }
  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew?WT_mc_id=SEC-MVP-5005282
  hFile := CreateFileW(
    PWideChar(AFileName),
    GENERIC_READ,
    FILE_SHARE_READ,
    nil,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    0
  );
  if hFile = INVALID_HANDLE_VALUE then
    raise EWindowsException.Create('CreateFileW');

  WriteLn(Format('File handle: [%x], move cursor to EOF...', [hFile]));

  { Place file cursor at the end of the file minus the size of malware config structure }
  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer?WT_mc_id=SEC-MVP-5005282
  if SetFilePointer(hFile, -SizeOf(TMalwareConfig), nil, FILE_END) = $FFFFFFFF {INVALID_SET_FILE_POINTER} then
    raise EWindowsException.Create('SetFilePointer');

  { Read EOF (Overlay) Data }
  WriteLn('Read EOF Data...');

  // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile?WT_mc_id=SEC-MVP-5005282
  if not ReadFile(hFile, AConfig, SizeOf(TMalwareConfig), ABytesRead, nil) then
    raise EWindowsException.Create('ReadFile');
end;

{ _.DumpMalwareConfig }
procedure DumpMalwareConfig(const AConfig : TMalwareConfig);
begin
  if AConfig.Magic <> MAGIC_NUMBER then
    WriteLn('[x] Invalid or Missing Malware Config!')
  else begin
    WriteLn(StringOfChar('-', 20));
    WriteLn('Config Dump');
    WriteLn(StringOfChar('-', 20));
    WriteLn;

    WriteLn('@Plain:');
    WriteLn(Format('-> Host: %s', [AConfig.Host]));
    WriteLn(Format('-> Port: %d', [AConfig.Port]));
    WriteLn(Format('-> File Name URI: %s', [AConfig.FileNameURI]));
    WriteLn(Format('-> Retry If Fails: %s', [BoolToStr(AConfig.RetryIfFail)]));
    WriteLn;

    WriteLn('@Raw:');
    WriteLn(BufferToHexView(@AConfig, SizeOf(TMalwareConfig)));
    WriteLn;
  end;
end;

(* Entry Point*)

var AConfig   : TMalwareConfig;
begin
  try
    WriteLn('Read EOF From File...');

    ReadMalwareConfig(GetModuleName(0), AConfig);

    DumpMalwareConfig(AConfig);

    ///
    WriteLn('Press return key to exit.');
    ReadLn;
  except
    on E: Exception do
      Writeln(E.ClassName, ': ', E.Message);
  end;
end.
