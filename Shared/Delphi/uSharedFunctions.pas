{******************************************************************************}
{                                                                              }
{                                                                              }
{                   Author: DarkCoderSc (Jean-Pierre LESUEUR)                  }
{                   https://www.twitter.com/darkcodersc                        }
{                   https://www.unprotect.it/                                  }
{                   https://github.com/Unprotect-Project                       }
{                   https://github.com/darkcodersc                             }
{                   https://github.com/PhrozenIO                               }
{                   License: Apache License 2.0                                }
{                                                                              }
{                                                                              }
{******************************************************************************}

unit uSharedFunctions;

interface

uses System.SysUtils,
     Winapi.Windows,
     Winapi.CommDlg,
     uPayload;

function PromptQuestion_Bool(const AQuestion: String) : Boolean;
function PromptQuestion(const AQuestion: String; const AMaxLen : Cardinal = 255) : String;
function PromptQuestion_Word(const AQuestion: String) : Word;
function OpenFileDialog(var AFileName : String): Boolean;
function BufferToHexView(const pBuffer : PVOID; const ABufferSize : UInt64) : String; overload;
procedure DumpMalwareConfig(const AConfig : TMalwareConfig);
procedure PromptPayloadConfiguration(var AConfig : TMalwareConfig);

implementation

{ _.PromptPayloadConfiguration }
procedure PromptPayloadConfiguration(var AConfig : TMalwareConfig);
begin
  ZeroMemory(@AConfig, SizeOf(TMalwareConfig));
  AConfig.Magic := MAGIC_NUMBER;
  AConfig.Host := PromptQuestion('Please enter server host', High(AConfig.Host));
  AConfig.Port := PromptQuestion_Word('Please enter server port');
  AConfig.FileNameURI := PromptQuestion('Please enter http server file name URI', High(AConfig.Host));
  AConfig.RetryIfFail := PromptQuestion_Bool('Retry if download fails');
end;

{ _.DumpMalwareConfig }
procedure DumpMalwareConfig(const AConfig : TMalwareConfig);
begin
  if AConfig.Magic <> MAGIC_NUMBER then
    WriteLn('[x] Invalid or Missing Malware Config!')
  else begin
    WriteLn(StringOfChar('-', 20));
    WriteLn('Config Dump');
    WriteLn(StringOfChar('-', 20));
    WriteLn;

    WriteLn('@Plain:');
    WriteLn(Format('-> Host: %s', [AConfig.Host]));
    WriteLn(Format('-> Port: %d', [AConfig.Port]));
    WriteLn(Format('-> File Name URI: %s', [AConfig.FileNameURI]));
    WriteLn(Format('-> Retry If Fails: %s', [BoolToStr(AConfig.RetryIfFail)]));
    WriteLn;

    WriteLn('@Raw:');
    WriteLn(BufferToHexView(@AConfig, SizeOf(TMalwareConfig)));
    WriteLn;
  end;
end;

{ _.BufferToHexView }
function BufferToHexView(const pBuffer : PVOID; const ABufferSize : UInt64) : String; overload;
var ARow           : array of byte;
    ABytesRead     : UInt64;
    x              : Byte;
    AStringBuilder : TStringBuilder;
    AHexBuilder    : TStringBuilder;
    AAsciiBuilder  : TStringBuilder;

    function PrintChar(const AChar : Byte) : Char;
    begin
      if AChar in [32..126] then
        result := Chr(AChar)
      else
        result := '.';
    end;

const SPACE = #32;

begin
  result := '';
  ///

  AStringBuilder := TStringBuilder.Create();
  AHexBuilder := TStringBuilder.Create(48);
  AAsciiBuilder := TStringBuilder.Create(16);
  try
    ABytesRead := 0;

    SetLength(ARow, 16);
    repeat
      if ABufferSize - ABytesRead < 16 then
        SetLength(ARow, ABufferSize - ABytesRead);
      ///

      CopyMemory(PByte(ARow), Pointer(NativeUInt(pBuffer) + ABytesRead), Length(ARow));

      AHexBuilder.Clear();
      AAsciiBuilder.Clear();

      for x := 0 to Length(ARow) -1 do begin
        AHexBuilder.Append(SPACE + IntToHex(ARow[x]));
        AAsciiBuilder.Append(PrintChar(ARow[x]));
      end;

      AStringBuilder.AppendLine(
        Format('%p:%p %-48s %s', [
          Pointer(NativeUInt(pBuffer) + ABytesRead),
          Pointer(ABytesRead),
          AHexBuilder.ToString(),
          AAsciiBuilder.ToString()
        ])
      );

      ///
      Inc(ABytesRead, Length(ARow));
    until ABytesRead = ABufferSize;

    ///
    result := AStringBuilder.ToString();
  finally
    if Assigned(AStringBuilder) then
      FreeAndNil(AStringBuilder);

    if Assigned(AHexBuilder) then
      FreeAndNil(AHexBuilder);

    if Assigned(AAsciiBuilder) then
      FreeAndNil(AAsciiBuilder);
  end;
end;

{ _.OpenFileDialog }
function OpenFileDialog(var AFileName : String): Boolean;
var AOpenFileName : OPENFILENAMEW;
    ABuffer       : array[0..MAX_PATH-1] of WideChar;
begin
  result := False;
  ///

  ZeroMemory(@AOpenFileName, SizeOf(OPENFILENAMEW));

  SetLength(AFileName, MAX_PATH);

  AOpenFileName.lStructSize := SizeOf(OPENFILENAMEW);
  AOpenFileName.hWndOwner := 0;
  AOpenFileName.Flags := (OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST);
  AOpenFileName.lpstrFile := @ABuffer;
  AOpenFileName.nMaxFile := MAX_PATH;

  if not GetOpenFileNameW(AOpenFileName) then
    Exit();

  AFileName := String(ABuffer);

  ///
  result := True;
end;

{ _.PromptQuestion }
function PromptQuestion(const AQuestion: String; const AMaxLen : Cardinal = 255) : String;
var ACandidate : String;
begin
  while True do begin
    Write(Format('%s? : ', [AQuestion]));

    ReadLn(ACandidate);

    if Length(ACandidate) > AMAxLen then
      WriteLn(Format('[x] Answer length is limited to a maximum of %d characters', [AMaxLen]))
    else
      break;
  end;

  result := ACandidate;
end;

{ _.PromptQuestion_Bool }
function PromptQuestion_Bool(const AQuestion: String) : Boolean;
var ACandidate : String;
    AResult    : Boolean;
    ACompare   : Integer;
begin
  while True do begin
    ACandidate := PromptQuestion(AQuestion, 5 { False Max Length });
    ///

    if String.Compare(ACandidate, 'True', True) = 0 then
      AResult := True
    else if String.Compare(ACandidate, 'False', True) = 0 then
      AResult := False
    else begin
      WriteLn('[x] Please answer "True" or "False".');

      continue;
    end;

    ///
    break;
  end;

  result := AResult;
end;

{ _.PromptQuestion_Word }
function PromptQuestion_Word(const AQuestion: String) : Word;
var ACandidate : String;
    AInteger   : Integer;
begin
  while True do begin
    ACandidate := PromptQuestion(AQuestion, 5 { Word Max Length });

    try
      if not TryStrToInt(ACandidate, AInteger) then
        raise Exception.Create('Answer must be a valid number.');

      if (AInteger < low(Word)) or (AInteger > high(Word)) then
        raise Exception.Create(
          Format('Answered number must be between %d and %d.', [
            low(Word),
            high(Word)
          ])
        );

      ///
      break;
    except
      on E : Exception do
        WriteLn(Format('[x] %s', [E.Message]));
    end;
  end;

  result := AInteger;
end;

end.
